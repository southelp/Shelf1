<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>책 표지 인식 앱</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');
        
        :root {
            --primary-color: #4CAF50;
            --secondary-color: #8BC34A;
            --background-color: #f0f4f8;
            --card-background: #ffffff;
            --text-color: #333;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --border-radius: 12px;
        }

        body {
            font-family: 'Noto Sans KR', sans-serif;
            background-color: var(--background-color);
            color: var(--text-color);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 20px;
            box-sizing: border-box;
        }

        .container {
            background-color: var(--card-background);
            padding: 30px;
            border-radius: var(--border-radius);
            box-shadow: 0 10px 25px var(--shadow-color);
            width: 100%;
            max-width: 600px;
            text-align: center;
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 20px;
            font-weight: 700;
        }

        #cameraFeed {
            width: 100%;
            height: auto;
            max-height: 300px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            border: 2px solid #ddd;
            display: block;
        }

        #recognizeBtn {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 700;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-top: 20px;
            width: 100%;
        }
        
        #recognizeBtn:hover {
            background-color: #0056b3;
        }

        #recognizeBtn:active {
            transform: scale(0.98);
        }

        .result-box {
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-top: 30px;
            text-align: left;
            border: 1px solid #eee;
        }

        .result-box h3 {
            margin-top: 0;
            color: #555;
        }

        .result-box p {
            margin: 8px 0;
            font-size: 15px;
        }
        
        .result-box strong {
            color: var(--primary-color);
        }
        
        .loading {
            margin-top: 20px;
            font-style: italic;
            color: #888;
        }

        /* 메시지 박스 스타일 */
        .message-box {
            background-color: #ffcccc;
            color: #d9534f;
            padding: 15px;
            border-radius: var(--border-radius);
            margin-top: 20px;
            text-align: center;
            font-weight: 700;
            border: 1px solid #d9534f;
            display: none;
        }

        .book-item {
            border-bottom: 1px solid #ddd;
            padding-bottom: 15px;
            margin-bottom: 15px;
        }

        .book-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>📚 책 표지 인식기</h1>
    <video id="cameraFeed" autoplay playsinline></video>
    <canvas id="photoCanvas" style="display:none;"></canvas>
    
    <button id="recognizeBtn">책 정보 인식하기</button>
    
    <p class="loading" id="loadingText" style="display: none;">
        로딩 중...
    </p>

    <!-- 메시지 박스 추가 -->
    <div id="messageBox" class="message-box"></div>

    <div class="result-box" id="resultBox" style="display: none;">
        <h3 id="resultSummary">인식 결과</h3>
        <div id="bookListContainer"></div>
    </div>
</div>

<script>
    // 카카오 REST API 키는 사용자 요청에 따라 직접 사용합니다.
    const KAKAO_REST_API_KEY = "046dac5667abf31ec98555fa419183f6";
    // Google API 키는 이 캔버스 환경에서 자동으로 제공됩니다.
    const GOOGLE_API_KEY = "AIzaSyBv1vyf8zo8SFxhHrB_uIVyf5Ax-A5z38M";

    const cameraFeed = document.getElementById('cameraFeed');
    const photoCanvas = document.getElementById('photoCanvas');
    const recognizeBtn = document.getElementById('recognizeBtn');
    const loadingText = document.getElementById('loadingText');
    const resultBox = document.getElementById('resultBox');
    const bookListContainer = document.getElementById('bookListContainer');
    const resultSummary = document.getElementById('resultSummary');
    const messageBox = document.getElementById('messageBox');

    let uploadedImageBase64 = null;
    let timer;

    /**
     * 사용자에게 메시지를 보여주는 함수. alert()를 대체합니다.
     * @param {string} message - 표시할 메시지
     * @param {boolean} isError - 오류 메시지 여부
     */
    function showMessage(message, isError = false) {
        messageBox.textContent = message;
        messageBox.style.display = 'block';
        if (isError) {
            messageBox.style.backgroundColor = '#f8d7da';
            messageBox.style.color = '#721c24';
        } else {
            messageBox.style.backgroundColor = '#d4edda';
            messageBox.style.color = '#155724';
        }
    }

    // 카메라 피드를 시작하는 함수
    async function startCamera() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: {
                    facingMode: 'environment' // 후면 카메라 우선 사용
                }
            });
            cameraFeed.srcObject = stream;
        } catch (error) {
            console.error("카메라 접근 오류:", error);
            showMessage("카메라에 접근할 수 없습니다. 권한을 허용해 주세요.", true);
            recognizeBtn.disabled = true;
        }
    }

    // 인식 버튼 클릭 시
    recognizeBtn.addEventListener('click', async function() {
        if (!cameraFeed.srcObject) {
            showMessage("카메라 피드가 준비되지 않았습니다.", true);
            return;
        }

        loadingText.style.display = 'block';
        resultBox.style.display = 'none';
        messageBox.style.display = 'none';
        
        // 6초 타임아웃 타이머 설정
        const timeoutPromise = new Promise((resolve, reject) => {
            timer = setTimeout(() => {
                reject(new Error("로딩 시간이 초과되었습니다. 다시 시도해 주세요."));
            }, 6000); // 6초
        });
        
        try {
            // 1. 카메라 영상에서 이미지 캡처
            const videoWidth = cameraFeed.videoWidth;
            const videoHeight = cameraFeed.videoHeight;
            photoCanvas.width = videoWidth;
            photoCanvas.height = videoHeight;
            const ctx = photoCanvas.getContext('2d');
            ctx.drawImage(cameraFeed, 0, 0, videoWidth, videoHeight);
            
            // 2. 캡처된 이미지를 1024x1024 픽셀 이하로 리사이징
            const resizedDataUrl = photoCanvas.toDataURL('image/jpeg');
            uploadedImageBase64 = await resizeImage(resizedDataUrl, 1024, 1024);

            // 3. Gemini API를 호출하여 책 표지 이미지에서 정보 추론
            const geminiPromise = callGeminiAPI(uploadedImageBase64);
            const geminiResult = await Promise.race([geminiPromise, timeoutPromise]);
            clearTimeout(timer);
            
            console.log("Gemini API 결과:", geminiResult);

            if (!geminiResult || !Array.isArray(geminiResult.books) || geminiResult.books.length === 0) {
                 throw new Error("인식 실패: Gemini API가 책 정보를 찾지 못했습니다.");
            }
            
            let successCount = 0;
            const totalBooks = geminiResult.books.length;
            bookListContainer.innerHTML = ''; // 기존 목록 초기화

            for (const geminiBook of geminiResult.books) {
                let bookDetails = null;
                try {
                    if (geminiBook.language === "Korean") {
                        // 4. 한국어 책일 경우 Kakao API 호출
                        const kakaoPromise = callKakaoAPI(geminiBook.title);
                        const kakaoResult = await Promise.race([kakaoPromise, timeoutPromise]);
                        clearTimeout(timer);
                        
                        if (kakaoResult && kakaoResult.documents && kakaoResult.documents.length > 0) {
                            const item = kakaoResult.documents[0];
                            bookDetails = {
                                title: item.title,
                                author: item.authors ? item.authors.join(', ') : "정보 없음",
                                isbn: item.isbn || "정보 없음",
                                description: item.contents ? item.contents.substring(0, 200) + '...' : "정보 없음"
                            };
                            successCount++;
                        } else {
                            throw new Error("카카오 API에서 정보를 찾을 수 없습니다.");
                        }
                    } else {
                        // 5. 외국어 책일 경우 Google Books API 호출
                        const googlePromise = callBooksAPI(geminiBook.title);
                        const googleResult = await Promise.race([googlePromise, timeoutPromise]);
                        clearTimeout(timer);

                        if (googleResult && googleResult.items && googleResult.items.length > 0) {
                            const item = googleResult.items[0].volumeInfo;
                            bookDetails = {
                                title: item.title,
                                author: item.authors ? item.authors.join(', ') : "정보 없음",
                                isbn: item.industryIdentifiers ? item.industryIdentifiers[0].identifier : "정보 없음",
                                description: item.description ? item.description.substring(0, 200) + '...' : "정보 없음"
                            };
                            successCount++;
                        } else {
                            throw new Error("Google Books API에서 정보를 찾을 수 없습니다.");
                        }
                    }
                } catch (apiError) {
                    console.error("개별 API 호출 오류:", apiError);
                    bookDetails = {
                        title: geminiBook.title,
                        author: geminiBook.author,
                        isbn: "인식 실패",
                        description: `API 검색 실패: ${apiError.message}`
                    };
                }
                
                // 결과를 화면에 표시
                const bookItemDiv = document.createElement('div');
                bookItemDiv.className = 'book-item';
                bookItemDiv.innerHTML = `
                    <p><strong>제목:</strong> <span>${bookDetails.title}</span></p>
                    <p><strong>저자:</strong> <span>${bookDetails.author}</span></p>
                    <p><strong>ISBN:</strong> <span>${bookDetails.isbn}</span></p>
                    <p><strong>설명:</strong> <span>${bookDetails.description}</span></p>
                `;
                bookListContainer.appendChild(bookItemDiv);
            }
            
            const failCount = totalBooks - successCount;
            resultSummary.textContent = `총 ${totalBooks}권 중 ${successCount}권 인식 성공. ${failCount}권 인식 실패.`;
            
        } catch (error) {
            clearTimeout(timer);
            console.error("오류 발생:", error);
            resultSummary.textContent = "인식 실패";
            bookListContainer.innerHTML = `<p>${error.message}</p>`;
        } finally {
            loadingText.style.display = 'none';
            resultBox.style.display = 'block';
        }
    });

    // 이미지 파일을 1024x1024 픽셀 이하로 리사이징하고 Base64로 반환합니다.
    function resizeImage(dataUrl, maxWidth, maxHeight) {
        return new Promise((resolve, reject) => {
            const img = new Image();
            img.onload = function() {
                let width = img.width;
                let height = img.height;
                
                if (width > height) {
                    if (width > maxWidth) {
                        height *= maxWidth / width;
                        width = maxWidth;
                    }
                } else {
                    if (height > maxHeight) {
                        width *= maxHeight / height;
                        height = maxHeight;
                    }
                }

                const canvas = document.createElement('canvas');
                canvas.width = width;
                canvas.height = height;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(img, 0, 0, width, height);

                const resizedDataUrl = canvas.toDataURL('image/jpeg');
                resolve(resizedDataUrl.split(',')[1]);
            };
            img.src = dataUrl;
        });
    }

    /**
     * Gemini API를 호출하여 책 표지 이미지에서 정보를 추론합니다.
     * @param {string} base64Image - Base64 인코딩된 이미지 데이터
     */
    async function callGeminiAPI(base64Image) {
        const prompt = `이 이미지는 책 표지를 여러 개 포함하고 있습니다. 각 책의 제목, 저자, 그리고 언어("Korean" 또는 "Foreign")를 JSON 배열 형식으로 추출해주세요. 여러 개의 책이 있으면 JSON 배열로 반환하고, 책이 한 개만 있어도 JSON 배열로 반환하세요.
        출력 형식: [{"title": "책 제목", "author": "저자", "language": "Korean" 또는 "Foreign"}]`;
        
        const payload = {
            contents: [
                {
                    role: "user",
                    parts: [
                        { text: prompt },
                        { inlineData: { mimeType: "image/jpeg", data: base64Image } }
                    ]
                }
            ],
            generationConfig: {
                responseMimeType: "application/json",
                responseSchema: {
                    type: "ARRAY",
                    items: {
                        type: "OBJECT",
                        properties: {
                            "title": { "type": "STRING" },
                            "author": { "type": "STRING" },
                            "language": { "type": "STRING" }
                        }
                    }
                }
            }
        };
        
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
        
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries) {
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.candidates && result.candidates.length > 0 &&
                        result.candidates[0].content && result.candidates[0].content.parts &&
                        result.candidates[0].content.parts.length > 0) {
                        const json = result.candidates[0].content.parts[0].text;
                        return { books: JSON.parse(json) };
                    } else {
                        throw new Error("Gemini API가 유효한 응답을 반환하지 않았습니다.");
                    }
                } else {
                    throw new Error(`Gemini API 오류: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                retries++;
                if (retries >= maxRetries) {
                    throw error;
                }
                const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    /**
     * 카카오 책 검색 API를 호출합니다.
     * @param {string} query - 책 제목
     */
    async function callKakaoAPI(query) {
        const kakaoUrl = `https://dapi.kakao.com/v3/search/book?target=title&query=${encodeURIComponent(query)}`;
        
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries) {
            try {
                const response = await fetch(kakaoUrl, {
                    method: 'GET',
                    headers: { 'Authorization': `KakaoAK ${KAKAO_REST_API_KEY}` }
                });
                
                if (response.ok) {
                    const data = await response.json();
                    return data;
                } else {
                    throw new Error(`Kakao API 오류: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                retries++;
                if (retries >= maxRetries) {
                    throw error;
                }
                const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }

    /**
     * Google Books API를 호출하여 책 정보 검색
     * @param {string} query - 제목/저자 검색어
     */
    async function callBooksAPI(query) {
        const booksUrl = `https://www.googleapis.com/books/v1/volumes?key=${GOOGLE_API_KEY}&q=${encodeURIComponent(query)}`;
        
        let retries = 0;
        const maxRetries = 3;
        while (retries < maxRetries) {
            try {
                const response = await fetch(booksUrl);
                
                if (response.ok) {
                    const data = await response.json();
                    return data;
                } else {
                    throw new Error(`Books API 오류: ${response.status} ${response.statusText}`);
                }
            } catch (error) {
                retries++;
                if (retries >= maxRetries) {
                    throw error;
                }
                const delay = Math.pow(2, retries) * 1000 + Math.random() * 1000;
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    // 페이지 로드 시 카메라 시작
    window.onload = startCamera;
</script>

</body>
</html>
